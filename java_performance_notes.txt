# Compiler Flags

######################
-XX:+PrintCompilation
######################

java -XX:+PrintCompilation Main 5000

- run from IntelliJ Terminal
C:\Users\rishi\Downloads\Study\Udemy\java-performance\PerformanceExample1\target\classes>

java -XX:+PrintCompilation com.rishi.Main 5000
java -XX:+PrintCompilation com.rishi.Main 15000

# sample output
...
...
    246   20  s    3       java.lang.StringBuffer::append (13 bytes)
    249   21       3       java.lang.String::<init> (82 bytes)
    249   22       3       java.lang.String::startsWith (7 bytes)
    250   23       3       java.util.HashMap::hash (20 bytes)
    251   24       1       java.util.ArrayList::size (5 bytes)
    251   25       3       java.lang.String::indexOf (70 bytes)
    251   26       3       java.util.HashMap::getNode (148 bytes)
    252   28     n 0       sun.misc.Unsafe::getObjectVolatile (native)   
    252   29       3       java.lang.String::indexOf (7 bytes)
    252   27       3       java.util.concurrent.ConcurrentHashMap::tabAt (21 bytes)
    253   30       1       java.lang.Integer::intValue (5 bytes)
    253   31       1       java.lang.Boolean::booleanValue (5 bytes)
    253   32       3       com.rishi.PrimeNumbers::isPrime (35 bytes)
    253   34       3       java.lang.Number::<init> (5 bytes)
    254   35       3       java.lang.Integer::<init> (10 bytes)
    254   33       3       java.lang.Integer::valueOf (32 bytes)
    254   36       3       java.util.ArrayList::add (29 bytes)
    254   38 %     4       com.rishi.PrimeNumbers::isPrime @ 2 (35 bytes)
    255   37       3       java.util.ArrayList::ensureCapacityInternal (13 bytes)
...
...
    369   39       3       com.rishi.PrimeNumbers::getNextPrimeAbove (43 bytes)   made not entrant
	


- First column is the timer in ms, that it took to run and its cumulative. Last row is the total time.
- Second column is the order that the line item was run.
- Third column is blank or 
n = native, s = synchronized
! would mean that some exception handling was going on
% would mean that the code has been natively compiled and is running in memory under the code cache.

- Fourth column has a value from 0 to 4. This corresponds as an ENUM to what type of compilation has taken place.
0: no compilation took place (code was interpreted)
1 through 4: is a range of compilation complexity (4 being greatest)

- Fifth and final column is the line item that was run.

# Compilers C1 & C2
There are two compilers in Java. 
C1 handles Native compilation levels 1-3, while C2 handles native level 4 only 
(which stores native compiles into the code cache).

The JVM determines the compilation level based on how often it is being run and 
how complex or time consuming it is â€“ through profiling.

As there is a tradeoff in optimizing more complex code (higher native tier/levels), 
it only will do this with methods that are called more often, or have greater complexity.

######################
# Outputting to a file
######################

java -XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation Main 5000

- creates a log file as : hotspot_pid11016.log

######################
-XX:+PrintCodeCache
-XX:ReservedCodeCacheSize=28m
######################

java -XX:+PrintCodeCache Main 5000

- prints the code cache size

- sample output
CodeCache: size=245760Kb used=1156Kb max_used=1168Kb free=244603Kb
 bounds [0x0000000002d70000, 0x0000000002fe0000, 0x0000000011d70000]
 total_blobs=300 nmethods=46 adapters=167
 compilation: enabled

size = around 20 MB
used = around 1 MB

- Java 8+ versions can have 240+ MB cache size
- tune params
InitialCodeCacheSize
ReservedCodeCacheSize
CodeCacheExpansionSize

----------------

java -XX:ReservedCodeCacheSize=28m -XX:+PrintCodeCache Main 5000

- sample output
CodeCache: size=28672Kb used=1256Kb max_used=1268Kb free=27416Kb
 bounds [0x0000000003020000, 0x0000000003290000, 0x0000000004c20000]
 total_blobs=345 nmethods=82 adapters=176
 compilation: enabled


######################
# 32-bit vs 64-bit JVM
######################

# 32-bit

VM argument: -client
java -client Main 5000

- object pointers are 32-bit
- faster if heap < 3g
- Max heap = 4g
- C1 or client compiler only (tier 1-3)
- faster start up time
- runs for a shorter time as a client

# 64-bit

VM argument: -server
java -server Main 5000

- object pointers are 64-bit
- mandatory if heap > 4g
- Max heap = OS dependent
- faster if using long/double
- C1 or client compiler and C2 or server compiler (tier 4)
- runs for a longer time as a server

If OS is 32-bit, only can use 
-client
-server

If OS is 64-bit, can use 
-client
-server
-d64


######################
-XX:-TieredCompilation
######################

only interpret and not compile !

java -XX:-TieredCompilation -XX:+PrintCompilation Main 5000

- only use for very small application with few lines of code


######################
# Compilation Tuning
-XX:CICompilerCount=n
-XX:CompileThreshold=n
######################

2 factors:
- no of threads involved in compilation
- threshold required for a method to run before its natively compiled and put in code cache
level 4 by C2

## no of threads
-XX:CICompilerCount=n

java -XX:+PrintFlagsFinal

- check for CICompilerCount
CICompilerCount = 3

so, 3 threads available for compilation

- another easier way to get threads
jinfo -flag CICompilerCount <pid>

sample output:
$ jinfo -flag CICompilerCount 13784
-XX:CICompilerCount=3

- increase threads and compile - doesn't make any difference if the code is small
java -XX:CICompilerCount=6 -XX:+PrintCompilation com.rishi.Main 15000

- default: atleast 2 threads for server JVM - for C1 and C2


## threshold
-XX:CompileThreshold=n

jinfo -flag CompileThreshold <pid>

- sample output
$ jinfo -flag CompileThreshold 13784
-XX:CompileThreshold=10000

- reduce the threshold
java -XX:CICompilerCount=4 -XX:CompileThreshold=1000 -XX:+PrintCompilation com.rishi.Main 15000

even worse performance


####################
# Java Memory Model
####################

- every thread has its own stack
- local variables are put in the executing thread stack
- local variables are removed from stack as soon as the scope ends
- always pass by value (copy)

- objects created on heap, shared by all the threads
- reference to objects is stored in thread stack


## Happens-before

Happens-before relationship is a guarantee that action performed by one thread 
is visible to another action in different thread.

If no happens-before, JIT compiler can reorder for optimization.

1. Single Thread rule
If a block of code is executed by a single thread, all the statements are executed in sequence.

2. Monitor Lock rule
An unlock on a monitor lock (exiting synchronized method/block) happens-before 
every subsequent acquiring on the same monitor lock.

3. Volatile variable rule
A write to a volatile field happens-before every subsequent read of that same field.

Writes and reads of volatile fields have similar memory consistency effects as 
entering and exiting monitors (synchronized block around reads and writes), 
but without actually aquiring monitors/locks.

4. Thread start rule
A call to Thread.start() on a thread happens-before every action in the started thread. 
Say thread A spawns a new thread B by calling threadA.start(). 
All actions performed in thread B's run method will see thread A's calling threadA.start() method and 
before that (only in thread A) happened before them.

5. Thread join rule
All actions in a thread happen-before any other thread successfully returns from a join on that thread. 
Say thread A spawns a new thread B by calling threadA.start() then calls threadA.join(). 
Thread A will wait at join() call until thread B's run method finishes.
After join method returns, all subsequent actions in thread A will see all actions performed in thread B's run method happened before them.


## Passing Objects between methods

- always pass by value
- final - helps for inlining by compilers  
variable, method, class

- java doesn't support "const correctness"
example:
final Customer c = new Customer("Rishi");

c can not point to any other object in heap, however, Customer object's state can be changed

## Escaping references

class having map reference
if map is having getter, it can cause the breach in encapsulation if called clear()

- strategy 1 is to pass iterator instead of getter for map
however it will still have remove method to mutate the map

- strategy 2 - return the copy of map
small memory footprint, however not ideal solution

- strategy 3 - return the copy but as an immutable map


 



